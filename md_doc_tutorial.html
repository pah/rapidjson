<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>RapidJSON: Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygenextra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="topbanner"><a href="https://github.com/miloyip/rapidjson" title="RapidJSON GitHub"><i class="githublogo"></i></a></div>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_doc_tutorial.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ValueDocument">Value & Document</a></li>
<li class="level1"><a href="#QueryValue">Query Value</a><ul><li class="level2"><a href="#QueryArray">Query Array</a></li>
<li class="level2"><a href="#QueryObject">Query Object</a></li>
<li class="level2"><a href="#QueryNumber">Querying Number</a></li>
<li class="level2"><a href="#QueryString">Query String</a></li>
</ul>
</li>
<li class="level1"><a href="#CreateModifyValues">Create/Modify Values</a><ul><li class="level2"><a href="#ChangeValueType">Change Value Type</a></li>
<li class="level2"><a href="#MoveSemantics">Move Semantics</a><ul><li class="level3"><a href="#TemporaryValues">Move semantics and temporary values</a></li>
</ul>
</li>
<li class="level2"><a href="#CreateString">Create String</a></li>
<li class="level2"><a href="#ModifyArray">Modify Array</a></li>
<li class="level2"><a href="#ModifyObject">Modify Object</a></li>
<li class="level2"><a href="#DeepCopyValue">Deep Copy Value</a></li>
<li class="level2"><a href="#SwapValues">Swap Values</a></li>
</ul>
</li>
<li class="level1"><a href="#WhatsNext">What's next</a></li>
</ul>
</div>
<div class="textblock"><p>This tutorial introduces the basics of the Document Object Model(DOM) API.</p>
<p>As shown in Usage at a glance, a JSON can be parsed into DOM, and then the DOM can be queried and modified easily, and finally be converted back to JSON.</p>
<h1><a class="anchor" id="ValueDocument"></a>
Value &amp; Document</h1>
<p>Each JSON value is stored in a type called <code>Value</code>. A <code>Document</code>, representing the DOM, contains the root of <code>Value</code>. All public types and functions of RapidJSON are defined in the <code>rapidjson</code> namespace.</p>
<h1><a class="anchor" id="QueryValue"></a>
Query Value</h1>
<p>In this section, we will use excerpt of <code>example/tutorial/tutorial.cpp</code>.</p>
<p>Assumes we have a JSON stored in a C string (<code>const char* json</code>): </p><div class="fragment"><div class="line">{</div>
<div class="line">    <span class="stringliteral">&quot;hello&quot;</span>: <span class="stringliteral">&quot;world&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;t&quot;</span>: true ,</div>
<div class="line">    <span class="stringliteral">&quot;f&quot;</span>: <span class="keyword">false</span>,</div>
<div class="line">    <span class="stringliteral">&quot;n&quot;</span>: null,</div>
<div class="line">    <span class="stringliteral">&quot;i&quot;</span>: 123,</div>
<div class="line">    <span class="stringliteral">&quot;pi&quot;</span>: 3.1416,</div>
<div class="line">    <span class="stringliteral">&quot;a&quot;</span>: [1, 2, 3, 4]</div>
<div class="line">}</div>
</div><!-- fragment --><p>Parse it into a <code>Document</code> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;rapidjson/document.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>rapidjson;</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><a class="code" href="classrapidjson_1_1_generic_document.html">Document</a> document;</div>
<div class="line">document.<a class="code" href="classrapidjson_1_1_generic_document.html#aed942fafd833c88f52b535daef620f8d">Parse</a>(json);</div>
</div><!-- fragment --><p>The JSON is now parsed into <code>document</code> as a <em>DOM tree</em>:</p>
<div class="image">
<img src="tutorial.png" alt="tutorial.png"/>
<div class="caption">
DOM in the tutorial</div></div>
<p> Since the update to RFC7159, the root of a conforming JSON document can be any JSON value. In RFC4627, only objects or arrays were allowed as root values. In this case, the root is an object. </p><div class="fragment"><div class="line">assert(document.IsObject());</div>
</div><!-- fragment --><p>Query whether a <code>"hello"</code> member exists in the root object. Since a <code>Value</code> can contain different types of value, we may need to verify its type and use suitable API to obtain the value. In this example, <code>"hello"</code> member associates with a JSON string. </p><div class="fragment"><div class="line">assert(document.HasMember(<span class="stringliteral">&quot;hello&quot;</span>));</div>
<div class="line">assert(document[<span class="stringliteral">&quot;hello&quot;</span>].IsString());</div>
<div class="line">printf(<span class="stringliteral">&quot;hello = %s\n&quot;</span>, document[<span class="stringliteral">&quot;hello&quot;</span>].GetString());</div>
</div><!-- fragment --><div class="fragment"><div class="line">world</div>
</div><!-- fragment --><p>JSON true/false values are represented as <code>bool</code>. </p><div class="fragment"><div class="line">assert(document[<span class="stringliteral">&quot;t&quot;</span>].IsBool());</div>
<div class="line">printf(<span class="stringliteral">&quot;t = %s\n&quot;</span>, document[<span class="stringliteral">&quot;t&quot;</span>].GetBool() ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">true</span></div>
</div><!-- fragment --><p>JSON null can be queryed by <code>IsNull()</code>. </p><div class="fragment"><div class="line">printf(<span class="stringliteral">&quot;n = %s\n&quot;</span>, document[<span class="stringliteral">&quot;n&quot;</span>].IsNull() ? <span class="stringliteral">&quot;null&quot;</span> : <span class="stringliteral">&quot;?&quot;</span>);</div>
</div><!-- fragment --><div class="fragment"><div class="line">null</div>
</div><!-- fragment --><p>JSON number type represents all numeric values. However, C++ needs more specific type for manipulation.</p>
<div class="fragment"><div class="line">assert(document[<span class="stringliteral">&quot;i&quot;</span>].IsNumber());</div>
<div class="line"></div>
<div class="line"><span class="comment">// In this case, IsUint()/IsInt64()/IsUInt64() also return true.</span></div>
<div class="line">assert(document[<span class="stringliteral">&quot;i&quot;</span>].IsInt());          </div>
<div class="line">printf(<span class="stringliteral">&quot;i = %d\n&quot;</span>, document[<span class="stringliteral">&quot;i&quot;</span>].GetInt());</div>
<div class="line"><span class="comment">// Alternative (int)document[&quot;i&quot;]</span></div>
<div class="line"></div>
<div class="line">assert(document[<span class="stringliteral">&quot;pi&quot;</span>].IsNumber());</div>
<div class="line">assert(document[<span class="stringliteral">&quot;pi&quot;</span>].IsDouble());</div>
<div class="line">printf(<span class="stringliteral">&quot;pi = %g\n&quot;</span>, document[<span class="stringliteral">&quot;pi&quot;</span>].GetDouble());</div>
</div><!-- fragment --><div class="fragment"><div class="line">i = 123</div>
<div class="line">pi = 3.1416</div>
</div><!-- fragment --><p>JSON array contains a number of elements. </p><div class="fragment"><div class="line"><span class="comment">// Using a reference for consecutive access is handy and faster.</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a>&amp; a = document[<span class="stringliteral">&quot;a&quot;</span>];</div>
<div class="line">assert(a.IsArray());</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="namespacerapidjson.html#a44eb33eaa523e36d466b1ced64b85c84">SizeType</a> i = 0; i &lt; a.Size(); i++) <span class="comment">// Uses SizeType instead of size_t</span></div>
<div class="line">        printf(<span class="stringliteral">&quot;a[%d] = %d\n&quot;</span>, i, a[i].GetInt());</div>
</div><!-- fragment --><div class="fragment"><div class="line">a[0] = 1</div>
<div class="line">a[1] = 2</div>
<div class="line">a[2] = 3</div>
<div class="line">a[3] = 4</div>
</div><!-- fragment --><p>Note that, RapidJSON does not automatically convert values between JSON types. If a value is a string, it is invalid to call <code>GetInt()</code>, for example. In debug mode it will fail an assertion. In release mode, the behavior is undefined.</p>
<p>In the following, details about querying individual types are discussed.</p>
<h2><a class="anchor" id="QueryArray"></a>
Query Array</h2>
<p>By default, <code>SizeType</code> is typedef of <code>unsigned</code>. In most systems, array is limited to store up to 2^32-1 elements.</p>
<p>You may access the elements in array by integer literal, for example, <code>a[1]</code>, <code>a[2]</code>. However, <code>a[0]</code> will generate a compiler error. It is because two overloaded operators <code>operator[](SizeType)</code> and <code>operator[](const char*)</code> is available, and C++ can treat <code>0</code> as a null pointer. Workarounds:</p><ul>
<li><code>a[SizeType(0)]</code></li>
<li><code>a[0u]</code></li>
</ul>
<p>Array is similar to <code>std::vector</code>, instead of using indices, you may also use iterator to access all the elements. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (Value::ConstValueIterator itr = a.Begin(); itr != a.End(); ++itr)</div>
<div class="line">    printf(<span class="stringliteral">&quot;%d &quot;</span>, itr-&gt;GetInt());</div>
</div><!-- fragment --><p>And other familiar query functions:</p><ul>
<li><code>SizeType Capacity() const</code></li>
<li><code>bool Empty() const</code></li>
</ul>
<h2><a class="anchor" id="QueryObject"></a>
Query Object</h2>
<p>Similar to array, we can iterate object members by iterator:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kTypeNames[] = </div>
<div class="line">    { <span class="stringliteral">&quot;Null&quot;</span>, <span class="stringliteral">&quot;False&quot;</span>, <span class="stringliteral">&quot;True&quot;</span>, <span class="stringliteral">&quot;Object&quot;</span>, <span class="stringliteral">&quot;Array&quot;</span>, <span class="stringliteral">&quot;String&quot;</span>, <span class="stringliteral">&quot;Number&quot;</span> };</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (Value::ConstMemberIterator itr = document.MemberBegin();</div>
<div class="line">    itr != document.MemberEnd(); ++itr)</div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;Type of member %s is %s\n&quot;</span>,</div>
<div class="line">        itr-&gt;name.GetString(), kTypeNames[itr-&gt;value.GetType()]);</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><a class="code" href="namespacerapidjson.html#ae79a4751c1c460ff0de5ecc07874f3e4">Type</a> of member hello is String</div>
<div class="line"><a class="code" href="namespacerapidjson.html#ae79a4751c1c460ff0de5ecc07874f3e4">Type</a> of member t is True</div>
<div class="line"><a class="code" href="namespacerapidjson.html#ae79a4751c1c460ff0de5ecc07874f3e4">Type</a> of member f is False</div>
<div class="line"><a class="code" href="namespacerapidjson.html#ae79a4751c1c460ff0de5ecc07874f3e4">Type</a> of member n is Null</div>
<div class="line"><a class="code" href="namespacerapidjson.html#ae79a4751c1c460ff0de5ecc07874f3e4">Type</a> of member i is Number</div>
<div class="line"><a class="code" href="namespacerapidjson.html#ae79a4751c1c460ff0de5ecc07874f3e4">Type</a> of member pi is Number</div>
<div class="line"><a class="code" href="namespacerapidjson.html#ae79a4751c1c460ff0de5ecc07874f3e4">Type</a> of member a is Array</div>
</div><!-- fragment --><p>Note that, when <code>operator[](const char*)</code> cannot find the member, it will fail an assertion.</p>
<p>If we are unsure whether a member exists, we need to call <code>HasMember()</code> before calling <code>operator[](const char*)</code>. However, this incurs two lookup. A better way is to call <code>FindMember()</code>, which can check the existence of member and obtain its value at once:</p>
<div class="fragment"><div class="line">Value::ConstMemberIterator itr = document.FindMember(<span class="stringliteral">&quot;hello&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (itr != document.MemberEnd())</div>
<div class="line">    printf(<span class="stringliteral">&quot;%s %s\n&quot;</span>, itr-&gt;value.GetString());</div>
</div><!-- fragment --><h2><a class="anchor" id="QueryNumber"></a>
Querying Number</h2>
<p>JSON provide a single numerical type called Number. Number can be integer or real numbers. RFC 4627 says the range of Number is specified by parser.</p>
<p>As C++ provides several integer and floating point number types, the DOM tries to handle these with widest possible range and good performance.</p>
<p>When the DOM parses a Number, it stores it as either one of the following type:</p>
<table class="doxtable">
<tr>
<th>Type </th><th>Description  </th></tr>
<tr>
<td><code>unsigned</code> </td><td>32-bit unsigned integer </td></tr>
<tr>
<td><code>int</code> </td><td>32-bit signed integer </td></tr>
<tr>
<td><code>uint64_t</code> </td><td>64-bit unsigned integer </td></tr>
<tr>
<td><code>int64_t</code> </td><td>64-bit signed integer </td></tr>
<tr>
<td><code>double</code> </td><td>64-bit double precision floating point </td></tr>
</table>
<p>When querying a number, you can check whether the number can be obtained as target type:</p>
<table class="doxtable">
<tr>
<th>Checking </th><th>Obtaining  </th></tr>
<tr>
<td><code>bool IsNumber()</code> </td><td>N/A </td></tr>
<tr>
<td><code>bool IsUint()</code> </td><td><code>unsigned GetUint()</code> </td></tr>
<tr>
<td><code>bool IsInt()</code> </td><td><code>int GetInt()</code> </td></tr>
<tr>
<td><code>bool IsUint64()</code> </td><td><code>uint64_t GetUint()</code> </td></tr>
<tr>
<td><code>bool IsInt64()</code> </td><td><code>int64_t GetInt64()</code> </td></tr>
<tr>
<td><code>bool IsDouble()</code> </td><td><code>double GetDouble()</code> </td></tr>
</table>
<p>Note that, an integer value may be obtained in various ways without conversion. For example, A value <code>x</code> containing 123 will make <code>x.IsInt() == x.IsUint() == x.IsInt64() == x.IsUint64() == true</code>. But a value <code>y</code> containing -3000000000 will only makes <code>x.IsInt64() == true</code>.</p>
<p>When obtaining the numeric values, <code>GetDouble()</code> will convert internal integer representation to a <code>double</code>. Note that, <code>int</code> and <code>uint</code> can be safely convert to <code>double</code>, but <code>int64_t</code> and <code>uint64_t</code> may lose precision (since mantissa of <code>double</code> is only 52-bits).</p>
<h2><a class="anchor" id="QueryString"></a>
Query String</h2>
<p>In addition to <code>GetString()</code>, the <code>Value</code> class also contains <code>GetStringLength()</code>. Here explains why.</p>
<p>According to RFC 4627, JSON strings can contain Unicode character <code>U+0000</code>, which must be escaped as <code>"\\u0000"</code>. The problem is that, C/C++ often uses null-terminated string, which treats `<code>\0'</code> as the terminator symbol.</p>
<p>To conform RFC 4627, RapidJSON supports string containing <code>U+0000</code>. If you need to handle this, you can use <code>GetStringLength()</code> API to obtain the correct length of string.</p>
<p>For example, after parsing a the following JSON string to <code>Document d</code>.</p>
<div class="fragment"><div class="line">{ <span class="stringliteral">&quot;s&quot;</span> :  <span class="stringliteral">&quot;a\u0000b&quot;</span> }</div>
</div><!-- fragment --><p> The correct length of the value <code>"a\\u0000b"</code> is 3. But <code>strlen()</code> returns 1.</p>
<p><code>GetStringLength()</code> can also improve performance, as user may often need to call <code>strlen()</code> for allocating buffer.</p>
<p>Besides, <code>std::string</code> also support a constructor:</p>
<div class="fragment"><div class="line">string(<span class="keyword">const</span> <span class="keywordtype">char</span>* s, <span class="keywordtype">size_t</span> count);</div>
</div><!-- fragment --><p>which accepts the length of string as parameter. This constructor supports storing null character within the string, and should also provide better performance.</p>
<h2>Comparing values</h2>
<p>You can use <code>==</code> and <code>!=</code> to compare values. Two values are equal if and only if they are have same type and contents. You can also compare values with primitive types. Here is an example.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (document[<span class="stringliteral">&quot;hello&quot;</span>] == document[<span class="stringliteral">&quot;n&quot;</span>]) <span class="comment">/*...*/</span>;    <span class="comment">// Compare values</span></div>
<div class="line"><span class="keywordflow">if</span> (document[<span class="stringliteral">&quot;hello&quot;</span>] == <span class="stringliteral">&quot;world&quot;</span>) <span class="comment">/*...*/</span>;          <span class="comment">// Compare value with literal string</span></div>
<div class="line"><span class="keywordflow">if</span> (document[<span class="stringliteral">&quot;i&quot;</span>] != 123) <span class="comment">/*...*/</span>;                  <span class="comment">// Compare with integers</span></div>
<div class="line"><span class="keywordflow">if</span> (document[<span class="stringliteral">&quot;pi&quot;</span>] != 3.14) <span class="comment">/*...*/</span>;                <span class="comment">// Compare with double.</span></div>
</div><!-- fragment --><p>Array and object must be <code>Value</code>s in order to be compared. They are equal if and only if their whole subtrees are equal.</p>
<p>Note that, currently if an object contains duplicated named member, comparing equality with any object is always <code>false</code>.</p>
<h1><a class="anchor" id="CreateModifyValues"></a>
Create/Modify Values</h1>
<p>There are several ways to create values. After a DOM tree is created and/or modified, it can be saved as JSON again using <code>Writer</code>.</p>
<h2><a class="anchor" id="ChangeValueType"></a>
Change Value Type</h2>
<p>When creating a Value or Document by default constructor, its type is Null. To change its type, call <code>SetXXX()</code> or assignment operator, for example:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacerapidjson.html#a660c934c2959121babf799b6cb206659">Document</a> d; <span class="comment">// Null</span></div>
<div class="line">d.SetObject();</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> v;    <span class="comment">// Null</span></div>
<div class="line">v.SetInt(10);</div>
<div class="line">v = 10;     <span class="comment">// Shortcut, same as above</span></div>
</div><!-- fragment --><h3>Overloaded Constructors</h3>
<p>There are also overloaded constructors for several types:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> b(<span class="keyword">true</span>);    <span class="comment">// calls Value(bool)</span></div>
<div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> i(-123);    <span class="comment">// calls Value(int)</span></div>
<div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> u(123u);    <span class="comment">// calls Value(unsigned)</span></div>
<div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> d(1.5);     <span class="comment">// calls Value(double)</span></div>
</div><!-- fragment --><p>To create empty object or array, you may use <code>SetObject()</code>/<code>SetArray()</code> after default constructor, or using the <code>Value(Type)</code> in one shot:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> o(<a class="code" href="namespacerapidjson.html#ae79a4751c1c460ff0de5ecc07874f3e4acf030b422a32c3647c7c5973bd4dd0a9">kObjectType</a>);</div>
<div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> a(<a class="code" href="namespacerapidjson.html#ae79a4751c1c460ff0de5ecc07874f3e4a058c622e1e7d59419ae58b895cbce468">kArrayType</a>);</div>
</div><!-- fragment --><h2><a class="anchor" id="MoveSemantics"></a>
Move Semantics</h2>
<p>A very special decision during design of RapidJSON is that, assignment of value does not copy the source value to destination value. Instead, the value from source is moved to the destination. For example,</p>
<div class="fragment"><div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> a(123);</div>
<div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> b(456);</div>
<div class="line">b = a;         <span class="comment">// a becomes a Null value, b becomes number 123.</span></div>
</div><!-- fragment --><div class="image">
<img src="move1.png" alt="move1.png"/>
<div class="caption">
Assignment with move semantics.</div></div>
<p> Why? What is the advantage of this semantics?</p>
<p>The simple answer is performance. For fixed size JSON types (Number, True, False, Null), copying them is fast and easy. However, For variable size JSON types (String, Array, Object), copying them will incur a lot of overheads. And these overheads are often unnoticed. Especially when we need to create temporary object, copy it to another variable, and then destruct it.</p>
<p>For example, if normal <em>copy</em> semantics was used:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> o(<a class="code" href="namespacerapidjson.html#ae79a4751c1c460ff0de5ecc07874f3e4acf030b422a32c3647c7c5973bd4dd0a9">kObjectType</a>);</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> contacts(<a class="code" href="namespacerapidjson.html#ae79a4751c1c460ff0de5ecc07874f3e4a058c622e1e7d59419ae58b895cbce468">kArrayType</a>);</div>
<div class="line">    <span class="comment">// adding elements to contacts array.</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    o.AddMember(<span class="stringliteral">&quot;contacts&quot;</span>, contacts);  <span class="comment">// deep clone contacts (may be with lots of allocations)</span></div>
<div class="line">    <span class="comment">// destruct contacts.</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="image">
<img src="move2.png" alt="move2.png"/>
<div class="caption">
Copy semantics makes a lots of copy operations.</div></div>
<p> The object <code>o</code> needs to allocate a buffer of same size as contacts, makes a deep clone of it, and then finally contacts is destructed. This will incur a lot of unnecessary allocations/deallocations and memory copying.</p>
<p>There are solutions to prevent actual copying these data, such as reference counting and garbage collection(GC).</p>
<p>To make RapidJSON simple and fast, we chose to use <em>move</em> semantics for assignment. It is similar to <code>std::auto_ptr</code> which transfer ownership during assignment. Move is much faster and simpler, it just destructs the original value, <code>memcpy()</code> the source to destination, and finally sets the source as Null type.</p>
<p>So, with move semantics, the above example becomes:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> o(<a class="code" href="namespacerapidjson.html#ae79a4751c1c460ff0de5ecc07874f3e4acf030b422a32c3647c7c5973bd4dd0a9">kObjectType</a>);</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> contacts(<a class="code" href="namespacerapidjson.html#ae79a4751c1c460ff0de5ecc07874f3e4a058c622e1e7d59419ae58b895cbce468">kArrayType</a>);</div>
<div class="line">    <span class="comment">// adding elements to contacts array.</span></div>
<div class="line">    o.AddMember(<span class="stringliteral">&quot;contacts&quot;</span>, contacts);  <span class="comment">// just memcpy() of contacts itself to the value of new member (16 bytes)</span></div>
<div class="line">    <span class="comment">// contacts became Null here. Its destruction is trivial.</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="image">
<img src="move3.png" alt="move3.png"/>
<div class="caption">
Move semantics makes no copying.</div></div>
<p> This is called move assignment operator in C++11. As RapidJSON supports C++03, it adopts move semantics using assignment operator, and all other modifying function like <code>AddMember()</code>, <code>PushBack()</code>.</p>
<h3><a class="anchor" id="TemporaryValues"></a>
Move semantics and temporary values</h3>
<p>Sometimes, it is convenient to construct a Value in place, before passing it to one of the "moving" functions, like <code>PushBack()</code> or <code>AddMember()</code>. As temporary objects can't be converted to proper Value references, the convenience function <code>Move()</code> is available:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> a(<a class="code" href="namespacerapidjson.html#ae79a4751c1c460ff0de5ecc07874f3e4a058c622e1e7d59419ae58b895cbce468">kArrayType</a>);</div>
<div class="line"><span class="comment">// a.PushBack(Value(42));       // will not compile</span></div>
<div class="line">a.PushBack(<a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a>().SetInt(42)); <span class="comment">// fluent API</span></div>
<div class="line">a.PushBack(<a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a>(42).Move());   <span class="comment">// same as above</span></div>
</div><!-- fragment --><h2><a class="anchor" id="CreateString"></a>
Create String</h2>
<p>RapidJSON provide two strategies for storing string.</p>
<ol type="1">
<li>copy-string: allocates a buffer, and then copy the source data into it.</li>
<li>const-string: simply store a pointer of string.</li>
</ol>
<p>Copy-string is always safe because it owns a copy of the data. Const-string can be used for storing string literal, and in-situ parsing which we will mentioned in Document section.</p>
<p>To make memory allocation customizable, RapidJSON requires user to pass an instance of allocator, whenever an operation may require allocation. This design is more flexible than STL's allocator type per class, as we can assign an allocator instance for each allocation.</p>
<p>Therefore, when we assign a copy-string, we call this overloaded <code>SetString()</code> with allocator:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacerapidjson.html#a660c934c2959121babf799b6cb206659">Document</a> document;</div>
<div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> author;</div>
<div class="line"><span class="keywordtype">char</span> buffer[10];</div>
<div class="line"><span class="keywordtype">int</span> len = sprintf(buffer, <span class="stringliteral">&quot;%s %s&quot;</span>, <span class="stringliteral">&quot;Milo&quot;</span>, <span class="stringliteral">&quot;Yip&quot;</span>); <span class="comment">// dynamically created string.</span></div>
<div class="line">author.SetString(buffer, len, document.GetAllocator());</div>
<div class="line">memset(buffer, 0, <span class="keyword">sizeof</span>(buffer));</div>
<div class="line"><span class="comment">// author.GetString() still contains &quot;Milo Yip&quot; after buffer is destroyed</span></div>
</div><!-- fragment --><p>In this example, we get the allocator from a <code>Document</code> instance. This is a common idiom when using RapidJSON. But you may use other instances of allocator.</p>
<p>Besides, the above <code>SetString()</code> requires length. This can handle null characters within a string. There is another <code>SetString()</code> overloaded function without the length parameter. And it assumes the input is null-terminated and calls a <code>strlen()</code>-like function to obtain the length.</p>
<p>Finally, for literal string or string with safe life-cycle can use const-string version of <code>SetString()</code>, which lacks allocator parameter. For string literals (or constant character arrays), simply passing the literal as parameter is safe and efficient:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> s;</div>
<div class="line">s.SetString(<span class="stringliteral">&quot;rapidjson&quot;</span>);    <span class="comment">// can contain null character, length derived at compile time</span></div>
<div class="line">s = <span class="stringliteral">&quot;rapidjson&quot;</span>;             <span class="comment">// shortcut, same as above</span></div>
</div><!-- fragment --><p>For plain string pointers, the RapidJSON requires to mark a string as safe before using it without copying. This can be achieved by using the <code>StringRef</code> function:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> * cstr = getenv(<span class="stringliteral">&quot;USER&quot;</span>);</div>
<div class="line"><span class="keywordtype">size_t</span> cstr_len = ...;                 <span class="comment">// in case length is available</span></div>
<div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> s;</div>
<div class="line"><span class="comment">// s.SetString(cstr);                  // will not compile</span></div>
<div class="line">s.SetString(<a class="code" href="structrapidjson_1_1_generic_string_ref.html#aa6b9fd9f6aa49405a574c362ba9af6b5">StringRef</a>(cstr));          <span class="comment">// ok, assume safe lifetime, null-terminated</span></div>
<div class="line">s = <a class="code" href="structrapidjson_1_1_generic_string_ref.html#aa6b9fd9f6aa49405a574c362ba9af6b5">StringRef</a>(cstr);                   <span class="comment">// shortcut, same as above</span></div>
<div class="line">s.SetString(<a class="code" href="structrapidjson_1_1_generic_string_ref.html#aa6b9fd9f6aa49405a574c362ba9af6b5">StringRef</a>(cstr,cstr_len)); <span class="comment">// faster, can contain null character</span></div>
<div class="line">s = <a class="code" href="structrapidjson_1_1_generic_string_ref.html#aa6b9fd9f6aa49405a574c362ba9af6b5">StringRef</a>(cstr,cstr_len);          <span class="comment">// shortcut, same as above</span></div>
</div><!-- fragment --><h2><a class="anchor" id="ModifyArray"></a>
Modify Array</h2>
<p>Value with array type provides similar APIs as <code>std::vector</code>.</p>
<ul>
<li><code>Clear()</code></li>
<li><code>Reserve(SizeType, Allocator&amp;)</code></li>
<li><code>Value&amp; PushBack(Value&amp;, Allocator&amp;)</code></li>
<li><code>template &lt;typename T&gt; GenericValue&amp; PushBack(T, Allocator&amp;)</code></li>
<li><code>Value&amp; PopBack()</code></li>
<li><code>ValueIterator Erase(ConstValueIterator pos)</code></li>
<li><code>ValueIterator Erase(ConstValueIterator first, ConstValueIterator last)</code></li>
</ul>
<p>Note that, <code>Reserve(...)</code> and <code>PushBack(...)</code> may allocate memory for the array elements, therefore require an allocator.</p>
<p>Here is an example of <code>PushBack()</code>:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> a(<a class="code" href="namespacerapidjson.html#ae79a4751c1c460ff0de5ecc07874f3e4a058c622e1e7d59419ae58b895cbce468">kArrayType</a>);</div>
<div class="line">Document::AllocatorType&amp; allocator = document.GetAllocator();</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 5; i &lt;= 10; i++)</div>
<div class="line">    a.PushBack(i, allocator);   <span class="comment">// allocator is needed for potential realloc().</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Fluent interface</span></div>
<div class="line">a.PushBack(<span class="stringliteral">&quot;Lua&quot;</span>, allocator).PushBack(<span class="stringliteral">&quot;Mio&quot;</span>, allocator);</div>
</div><!-- fragment --><p>Differs from STL, <code>PushBack()</code>/<code>PopBack()</code> returns the array reference itself. This is called <em>fluent interface</em>.</p>
<p>If you want to add a non-constant string or a string without sufficient lifetime (see <a href="#CreateString">Create String</a>) to the array, you need to create a string Value by using the copy-string API. To avoid the need for an intermediate variable, you can use a <a href="#TemporaryValues">temporary value</a> in place:</p>
<div class="fragment"><div class="line"><span class="comment">// in-place Value parameter</span></div>
<div class="line">contact.PushBack(<a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a>(<span class="stringliteral">&quot;copy&quot;</span>, document.GetAllocator()).Move(), <span class="comment">// copy string</span></div>
<div class="line">                 document.GetAllocator());</div>
<div class="line"></div>
<div class="line"><span class="comment">// explicit parameters</span></div>
<div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> val(<span class="stringliteral">&quot;key&quot;</span>, document.GetAllocator()); <span class="comment">// copy string</span></div>
<div class="line">contact.PushBack(val, document.GetAllocator());</div>
</div><!-- fragment --><h2><a class="anchor" id="ModifyObject"></a>
Modify Object</h2>
<p>Object is a collection of key-value pairs. Each key must be a string value. The way to manipulating object is to add members:</p>
<ul>
<li><code>Value&amp; AddMember(Value&amp;, Value&amp;, Allocator&amp; allocator)</code></li>
<li><code>Value&amp; AddMember(StringRefType, Value&amp;, Allocator&amp;)</code></li>
<li><code>template &lt;typename T&gt; Value&amp; AddMember(StringRefType, T value, Allocator&amp;)</code></li>
</ul>
<p>Here is an example.</p>
<div class="fragment"><div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> contact(kObject);</div>
<div class="line">contact.AddMember(<span class="stringliteral">&quot;name&quot;</span>, <span class="stringliteral">&quot;Milo&quot;</span>, document.GetAllocator());</div>
<div class="line">contact.AddMember(<span class="stringliteral">&quot;married&quot;</span>, <span class="keyword">true</span>, document.GetAllocator());</div>
</div><!-- fragment --><p>The <code>StringRefType</code> used as name parameter assumes the same interface as the <code>SetString</code> function for string values. These overloads are used to avoid the need for copying the <code>name</code> string, as constant key names are very common in JSON objects.</p>
<p>If you need to create a name from a non-constant string or a string without sufficient lifetime (see <a href="#CreateString">Create String</a>), you need to create a string Value by using the copy-string API. To avoid the need for an intermediate variable, you can use a <a href="#TemporaryValues">temporary value</a> in place:</p>
<div class="fragment"><div class="line"><span class="comment">// in-place Value parameter</span></div>
<div class="line">contact.AddMember(<a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a>(<span class="stringliteral">&quot;copy&quot;</span>, document.GetAllocator()).Move(), <span class="comment">// copy string</span></div>
<div class="line">                  <a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a>().Move(),                                <span class="comment">// null value</span></div>
<div class="line">                  document.GetAllocator());</div>
<div class="line"></div>
<div class="line"><span class="comment">// explicit parameters</span></div>
<div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> key(<span class="stringliteral">&quot;key&quot;</span>, document.GetAllocator()); <span class="comment">// copy name string</span></div>
<div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> val(42);                             <span class="comment">// some value</span></div>
<div class="line">contact.AddMember(key, val, document.GetAllocator());</div>
</div><!-- fragment --><p>For removing members, there are several choices:</p>
<ul>
<li><code>bool RemoveMember(const Ch* name)</code>: Remove a member by search its name (linear time complexity).</li>
<li><code>bool RemoveMember(const Value&amp; name)</code>: same as above but <code>name</code> is a Value.</li>
<li><code>MemberIterator RemoveMember(MemberIterator)</code>: Remove a member by iterator (<em>constant</em> time complexity).</li>
<li><code>MemberIterator EraseMember(MemberIterator)</code>: similar to the above but it preserves order of members (linear time complexity).</li>
<li><code>MemberIterator EraseMember(MemberIterator first, MemberIterator last)</code>: remove a range of members, preserves order (linear time complexity).</li>
</ul>
<p><code>MemberIterator RemoveMember(MemberIterator)</code> uses a "move-last" trick to archive constant time complexity. Basically the member at iterator is destructed, and then the last element is moved to that position. So the order of the remaining members are changed.</p>
<h2><a class="anchor" id="DeepCopyValue"></a>
Deep Copy Value</h2>
<p>If we really need to copy a DOM tree, we can use two APIs for deep copy: constructor with allocator, and <code>CopyFrom()</code>.</p>
<div class="fragment"><div class="line"><a class="code" href="namespacerapidjson.html#a660c934c2959121babf799b6cb206659">Document</a> d;</div>
<div class="line">Document::AllocatorType&amp; a = d.GetAllocator();</div>
<div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> v1(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line"><span class="comment">// Value v2(v1); // not allowed</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> v2(v1, a);                      <span class="comment">// make a copy</span></div>
<div class="line">assert(v1.IsString());                <span class="comment">// v1 untouched</span></div>
<div class="line">d.SetArray().PushBack(v1, a).PushBack(v2, a);</div>
<div class="line">assert(v1.IsNull() &amp;&amp; v2.IsNull());   <span class="comment">// both moved to d</span></div>
<div class="line"></div>
<div class="line">v2.CopyFrom(d, a);                    <span class="comment">// copy whole document to v2</span></div>
<div class="line">assert(d.IsArray() &amp;&amp; d.Size() == 2); <span class="comment">// d untouched</span></div>
<div class="line">v1.SetObject().AddMember(<span class="stringliteral">&quot;array&quot;</span>, v2, a);</div>
<div class="line">d.PushBack(v1, a);</div>
</div><!-- fragment --><h2><a class="anchor" id="SwapValues"></a>
Swap Values</h2>
<p><code>Swap()</code> is also provided.</p>
<div class="fragment"><div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> a(123);</div>
<div class="line"><a class="code" href="namespacerapidjson.html#afb3fa116c66d834b6f4289d648cc8d6d">Value</a> b(<span class="stringliteral">&quot;Hello&quot;</span>);</div>
<div class="line">a.Swap(b);</div>
<div class="line">assert(a.IsString());</div>
<div class="line">assert(b.IsInt());</div>
</div><!-- fragment --><p>Swapping two DOM trees is fast (constant time), despite the complexity of the trees.</p>
<h1><a class="anchor" id="WhatsNext"></a>
What's next</h1>
<p>This tutorial shows the basics of DOM tree query and manipulation. There are several important concepts in RapidJSON:</p>
<ol type="1">
<li><a class="el" href="md_doc_stream.html">Streams</a> are channels for reading/writing JSON, which can be a in-memory string, or file stream, etc. User can also create their streams.</li>
<li><a class="el" href="md_doc_encoding.html">Encoding</a> defines which character set is used in streams and memory. RapidJSON also provide Unicode conversion/validation internally.</li>
<li><a class="el" href="md_doc_dom.html">DOM</a>'s basics are already covered in this tutorial. Uncover more advanced features such as <em>in situ</em> parsing, other parsing options and advanced usages.</li>
<li><a class="el" href="md_doc_sax.html">SAX</a> is the foundation of parsing/generating facility in RapidJSON. Learn how to use <code>Reader</code>/<code>Writer</code> to implement even faster applications. Also try <code>PrettyWriter</code> to format the JSON.</li>
<li><a class="el" href="md_doc_performance.html">Performance</a> shows some in-house and third-party benchmarks.</li>
<li><a class="el" href="md_doc_internals.html">Internals</a> describes some internal designs and techniques of RapidJSON.</li>
</ol>
<p>You may also refer to the FAQ, API documentation, examples and unit tests. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
